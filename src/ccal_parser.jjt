/*
Here are the options for the programme as a whole. All we need is to ignore cases so we place that option here
*/
options {
   IGNORE_CASE = true;
   MULTI=true;
   VISITOR=true;
   NODE_DEFAULT_VOID=true;
   NODE_EXTENDS="BaseNode";
 }

/*
    Here we start the definition of our parser. This defines the entry through which the parsing will begin. 
    We allow for a file to be passed in or for tokens to be fed into the command line
*/
PARSER_BEGIN(CCALParser)

public class CCALParser {

    public static void main(String [] args){

          //Parser initialization
          CCALParser parser;

          if(args.length == 0){
            System.out.println ("CCALParser: Reading input ...");
            parser = new CCALParser(System.in);
          }
          else if(args.length == 1){
            System.out.println ("CCALParser: Reading the file " + args[0] + " ..." );
            try {
              parser = new CCALParser(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e) {
              System.out.println ("CCALParser: The file " + args[0] + " was not found.");
              return;
            }
          }
          else {
            System.out.println ("CCALParser:  You must use one of the following:");
            System.out.println ("         java CCALParser < file");
            System.out.println ("Or");
            System.out.println ("         java CCALParser file");
            return ;
          }
          try {
            ASTprogramme root = parser.Programme();
            //root.dump("");
            Visitor v = new Visitor();
            System.out.println(root.jjtAccept(v,null));
            System.out.println ("CCALParser: The input was read successfully.");

          }
          catch(ParseException e){
            System.out.println ("CCALParser: There was an error during the parse.");
            System.out.println (e.getMessage());
          }
          catch(TokenMgrError e){
            System.out.println ("CCALParser: There was an error.");
            System.out.println (e.getMessage());
          }
        }
    }

PARSER_END (CCALParser)

/*
    Below defines what we'll ignore during the parsing, this includes new lines and nested comments
*/

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

//Newline/space skips
SKIP: { "\n" | "\r" | "\r\n" |"\t"|" "}

//Comment Skips
SKIP :
{
    "/*" { commentNesting++; } : IN_COMMENT
    | <"//" (~["\n"])* "\n">
}

//https://goo.gl/RFkbtP
<IN_COMMENT> SKIP : {
   "/*" { commentNesting++;}
   | "*/" { commentNesting--;
            if(commentNesting == 0)
                SwitchTo(DEFAULT);
            }
   |<~[]>

}

/*
    These are the accepted tokens used within the language defined through http://www.computing.dcu.ie/~davids/courses/CA4003/ccal.pdf
*/

TOKEN :
{
      <ASIGN:("=")>
    | <PLUS:("+")>
    | <MINUS:("-")>
    | <TILDA:("~")>
    | <OR:("||")>
    | <AND:("&&")>
    | <EQ:("==")>
    | <NOTEQ:("!=")>
    | <LT:("<")>
    | <LTEQ:("<=")>
    | <GT:(">")>
    | <GTEQ:(">=")>
    | <COMMA:(",")>
    | <COLON:(":")>
    | <SCOLON:(";")>
    | <OPBRA :("(")>
    | <CLBRA:(")")>
    | <VAR: "var">
    | <CONST: "const">
    | <RET: "return">
    | <INT: "integer">
    | <BOOL: "boolean">
    | <VOID: "void">
    | <MAIN: "main">
    | <IF: "if">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <WHILE: "while">
    | <BEGIN: "begin">
    | <END: "end">
    | <IS: "is">
    | <SKI: ("skip")>
    | <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|<SPECHAR>)*>
    | <DIGIT: "0" | ("-")? ["1" - "9"] (["0" - "9"])*> //Ensure 0s are taken care of in any form
    | <LETTER: (["a"-"z","A"-"Z"])>
    | <SPECHAR : "_"> //special characters used in variable names
}

//Start the parsing here
//Break down the programme into a list of declarations,functions and it's main method
ASTprogramme Programme () #programme: {}
{
    declarationList(){}
    functionList(){}
    mainMethod(){}
    {return jjtThis;}
}

//Take the structure of a main method and make sub calls to the inner structures
void mainMethod () : {}
{
    <MAIN> {}
    <BEGIN> {}
    declarationList() {}
    statementBlock() {}
    <END> {}
}

//Made up of zero or more functions
void functionList (): {}
{
    (function())*
}

//Function broken down into tokens
void function (): {
int paramCount = 0;
}
{
    type() identifier()<OPBRA>{paramCount = paramList();}<CLBRA><IS> { jjtThis.data.put("paramCount",Integer.toString(paramCount)); } #FunctionHeader
    declarationList() {}
    <BEGIN> {}
    statementBlock() {}
    <RET><OPBRA>(expression() | {})<CLBRA><SCOLON> {}
    <END>{}
}

//Can be a list of parameters or nothing at all
int paramList (): {
int paramCount = 0;
}
{
    (((<COMMA>|{})identifier()<COLON>type(){paramCount++;})+ | {}){return paramCount;}
}

//A statement block can have zero or more statements
void statementBlock () : {}
{
    (statement())*{}
}

//Break statement structure down into tokesn
void statement (): {}
{
    //Take multiple options for a statement into account in one line
    identifier()(<ASIGN>expression() #StatementAssignment| <OPBRA>argList()<CLBRA>)<SCOLON>
    | (<IF> | <WHILE>) conditionInteraction() <BEGIN> statementBlock() <END>
    | (<ELSE> | {}) <BEGIN> statementBlock() <END>
    | <SKI><SCOLON>
}

//Tokenize structure of condition and return back the amount of brackets used
int condition (int bracketCount) : {}
{
    (<OPBRA> {bracketCount++; } | {})
    expression()comparisionOp()expression()
    (<CLBRA>{bracketCount--; } | {})
    {return bracketCount;}
}

//Tokenize one or more conditions while keeping trakc of any brackets/nested brackets 
void conditionInteraction () : {
int bracketCount = 0;
}
{

    (<TILDA> | {}){bracketCount = condition(bracketCount); System.out.println("Bracket Count = " + bracketCount);}
    ((<OR> | <AND>){bracketCount = condition(bracketCount); System.out.println("Bracket Count = " + bracketCount);})*{if(bracketCount != 0) throw new ParseException("Brackets not closed correctly");}
}

//Comparison operators
void comparisionOp () : {}
{
    <EQ> {}
    | <NOTEQ> {}
    | <LT> {}
    | <LTEQ> {}
    | <GT> {}
    | <GTEQ> {}
}

//Zero or more declarations
void declarationList () : {}
{
    (declaration()<SCOLON>)*
}

//A declaration can be a variable declaration or a constant decalration
void declaration () : {}
{
    varDeclaration()|constDeclaration() {}
}

//Tokenize constant decalration
void constDeclaration () #constdeclaration: {}
{
    <CONST>identifier()<COLON>type()<ASIGN>expression() {}
}

//Tokenize variable decalration
void varDeclaration () #vardeclaration: {}
{
    <VAR>identifier()<COLON>type() {}
}

//Tokenize structure of expression
void expression () : {}
{
    //Moved some of the structure of a fragment into the expression
    /*
    As an identifier is part of a fragment and expression there is no need to have it in both,
    by removing it from a fragment we remove the need for a lookahead to see which tokens we should be 
    reading in after
    */
    fragment()(binOp()fragment() | {}) //still keeping posibility of negative identifier from fragment
    |identifier()(<OPBRA>argList()<CLBRA>|binOp()(identifier()|fragment())|{}) //positive identifier from fragment integrated here
    |<OPBRA>expression()<CLBRA>

    {}
}

//Tokenize the remaining structures of a fragment
void fragment () #VariableValue: {}
{
    <MINUS>(identifier()|<DIGIT>){ jjtThis.data.put("value",token.image); jjtThis.data.put("type","integer");}
    | <DIGIT>{ jjtThis.data.put("value",token.image); jjtThis.data.put("type","integer");}
    | boolOp(){ jjtThis.data.put("value",token.image); jjtThis.data.put("type","boolean"); }

}

//Can be a list of arguments or nothing
void argList () : {}
{
    ((<COMMA>|{})identifier())+ | {}
}

//Tokenize identifier
void identifier () : {}
{
    <IDENTIFIER>{ jjtThis.data.put("name",token.image); }#Variable
}

//Tokenize structure of a type
void type () #TypeValue: {}
{
    <INT> { jjtThis.data.put("type",token.image); }
    |<BOOL> { jjtThis.data.put("type",token.image); }
    |<VOID> { jjtThis.data.put("type",token.image); }
}

//Boolean operations
void boolOp() : {}
{
    <TRUE>{}
    |<FALSE>{}
}

//Binary operations
void binOp() : {}
{
    <PLUS> {}
    |<MINUS> {}
}