/* Sample grammar file*/
options {
   IGNORE_CASE = true;
 }

PARSER_BEGIN(CCALParser)

public class CCALParser {

    public static void main(String [] args){

          //Parser initialization
          CCALParser parser;

          if(args.length == 0){
            System.out.println ("CCALParser: Reading input ...");
            parser = new CCALParser(System.in);
          }
          else if(args.length == 1){
            System.out.println ("CCALParser: Reading the file " + args[0] + " ..." );
            try {
              parser = new CCALParser(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e) {
              System.out.println ("CCALParser: The file " + args[0] + " was not found.");
              return;
            }
          }
          else {
            System.out.println ("CCALParser:  You must use one of the following:");
            System.out.println ("         java CCALParser < file");
            System.out.println ("Or");
            System.out.println ("         java CCALParser file");
            return ;
          }
          try {
            Start();
            System.out.println ("CCALParser: The input was readed sucessfully.");
          }
          catch(ParseException e){
            System.out.println ("CCALParser: There was an error during the parse.");
            System.out.println (e.getMessage());
          }
          catch(TokenMgrError e){
            System.out.println ("CCALParser: There was an error.");
            System.out.println (e.getMessage());
          }
        }
    }

PARSER_END (CCALParser)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

SKIP: { "\n" | "\r" | "\r\n" |"\t"|" "}

//Comment Skips
SKIP :
{
    "/*" { commentNesting++; } : IN_COMMENT
    | <"//" (~["\n"])* "\n">
}

//https://goo.gl/RFkbtP
<IN_COMMENT> SKIP : {
   "/*" { commentNesting++;}
   | "*/" { commentNesting--;
            if(commentNesting == 0)
                SwitchTo(DEFAULT);
            }
   |<~[]>

}

TOKEN :
{
      <ASIGN:("=")>
    | <PLUS:("+")>
    | <MINUS:("-")>
    | <TILDA:("~")>
    | <OR:("||")>
    | <AND:("&&")>
    | <EQ:("==")>
    | <NOTEQ:("!=")>
    | <LT:("<")>
    | <LTEQ:("<=")>
    | <GT:(">")>
    | <GTEQ:(">=")>
    | <COMMA:(",")>
    | <COLON:(":")>
    | <SCOLON:(";")>
    | <OBRA :("(")>
    | <CBRA:(")")>
    | <VAR: "var">
    | <CONST: "const">
    | <RET: "return">
    | <INT: "integer">
    | <BOOL: "boolean">
    | <VOID: "void">
    | <MAIN: "main">
    | <IF: "if">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <WHILE: "while">
    | <BEGIN: "begin">
    | <END: "end">
    | <IS: "is">
    | <SKI: ("skip")>
    | <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|<SPECHAR>)*>
    | <DIGIT: ["0"-"9"]>
    | <LETTER: (["a"-"z","A"-"Z"])>
    | <SPECHAR : "_">
}

void Start () : {}
{
  Programme()
}

void Programme () : {}
{
    declarationList()
    functionList()
    mainMethod()
}

void mainMethod () : {}
{
    <MAIN><BEGIN>declarationList()statementBlock()<END>
}

void functionList () : {}
{
    (function())+|{}
}

void function () : {}
{
    type()identifier()<OBRA>paramList()<CBRA><IS>declarationList()<BEGIN>statementBlock()<RET><OBRA>(expression() | {})<CBRA><SCOLON><END>
}

void paramList () : {}
{
    nonEmptyParamList() | {}
}

void nonEmptyParamList () : {}
{
    ((<COMMA>|{})identifier()<COLON>type())+

}

void statementBlock () : {}
{
    (statement())+|{}
}

void statement () : {}
{

    identifier()(<ASIGN>expression()| <OBRA>argList()<CBRA>)<SCOLON>
    | (<IF> | <WHILE>) conditionInteraction() <BEGIN> statementBlock() <END>
    | (<ELSE> | {}) <BEGIN> statementBlock() <END>
    | <SKI><SCOLON>
}

void condition () : {}
{
    (<OBRA> | {})
    expression()comparisionOp()expression()
    (<CBRA> | {})
}

void conditionInteraction () : {}
{

    (<TILDA> | {})condition()((<OR> | <AND>)condition())*
}

void comparisionOp () : {}
{
    <EQ> | <NOTEQ> | <LT> | <LTEQ> | <GT> | <GTEQ>
}

void declarationList () : {}
{
    (declaration()<SCOLON>)+|{}
}

void declaration () : {}
{
    varDeclaration()|constDeclaration() {System.out.println("Declaration");}
}

void constDeclaration () : {}
{
    <CONST>identifier()<COLON>type()<ASIGN>expression() {System.out.println("Const decalration");}
}

void varDeclaration () : {}
{
    <VAR><IDENTIFIER><COLON>type() {System.out.println("Var declaration");}
}

void expression () : {}
{
    fragment()(BinOp()fragment() | {})
    |identifier()(<OBRA>argList()<CBRA>|BinOp()(identifier()|fragment())|{})
    |<OBRA>expression()<CBRA>
}

void fragment () : {}
{
    <MINUS>(identifier()|<DIGIT>){System.out.println("Negative identifier");}
    | <DIGIT>{System.out.println("Number fragment");}
    | boolOp(){System.out.println("Boolean fragment");}

}

void argList () : {}
{
    nonEmptyArgList() | {}
}

void nonEmptyArgList () : {}
{
    ((<COMMA>|{})identifier())+
}

void identifier () : {}
{
    <IDENTIFIER>{System.out.println("IDENTIFIER");}
}

void type () : {}
{
    <INT> {System.out.println("Integer Type");}
    |<BOOL> {System.out.println("Boolean Type");}
    |<VOID> {System.out.println("Void Type");}
}

void boolOp() : {}
{
    <TRUE>{System.out.println("True");}
    |<FALSE>{System.out.println("False");}
}


void BinOp() : {}
{
    <PLUS> {System.out.println("Plus operator");}
    |<MINUS> {System.out.println("Minus operator");}
}