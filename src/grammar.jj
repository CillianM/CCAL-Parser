/* Sample grammar file*/
options {
   IGNORE_CASE = true;
 }

PARSER_BEGIN(CCALParser)

public class CCALParser {

    public static void main(String [] args){

          //Parser initialization
          CCALParser parser;

          if(args.length == 0){
            System.out.println ("CCALParser: Reading input ...");
            parser = new CCALParser(System.in);
          }
          else if(args.length == 1){
            System.out.println ("CCALParser: Reading the file " + args[0] + " ..." );
            try {
              parser = new CCALParser(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e) {
              System.out.println ("CCALParser: The file " + args[0] + " was not found.");
              return;
            }
          }
          else {
            System.out.println ("CCALParser:  You must use one of the following:");
            System.out.println ("         java CCALParser < file");
            System.out.println ("Or");
            System.out.println ("         java CCALParser file");
            return ;
          }
          try {
            Start();
            System.out.println ("CCALParser: The input was readed sucessfully.");
          }
          catch(ParseException e){
            System.out.println ("CCALParser: There was an error during the parse.");
            System.out.println (e.getMessage());
          }
          catch(TokenMgrError e){
            System.out.println ("CCALParser: There was an error.");
            System.out.println (e.getMessage());
          }
        }
    }

PARSER_END (CCALParser)

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

SKIP: { "\n" | "\r" | "\r\n" |"\t"|" "}

//Comment Skips
SKIP :
{
    "/*" { commentNesting++; } : IN_COMMENT
    | <"//" (~["\n"])* "\n">
}

//https://goo.gl/RFkbtP
<IN_COMMENT> SKIP : {
   "/*" { commentNesting++;}
   | "*/" { commentNesting--;
            if(commentNesting == 0)
                SwitchTo(DEFAULT);
            }
   |<~[]>

}

TOKEN :
{
      <ASIGN:("=")>
    | <PLUS:("+")>
    | <MINUS:("-")>
    | <TILDA:("~")>
    | <OR:("||")>
    | <AND:("&&")>
    | <EQ:("==")>
    | <NOTEQ:("!=")>
    | <LT:("<")>
    | <LTEQ:("<=")>
    | <GT:(">")>
    | <GTEQ:(">=")>
    | <COMMA:(",")>
    | <COLON:(":")>
    | <SCOLON:(";")>
    | <OBRA :("(")>
    | <CBRA:(")")>
    | <VAR: "var">
    | <CONST: "const">
    | <RET: "return">
    | <INT: "integer">
    | <BOOL: "boolean">
    | <VOID: "void">
    | <MAIN: "main">
    | <IF: "if">
    | <ELSE: "else">
    | <TRUE: "true">
    | <FALSE: "false">
    | <WHILE: "while">
    | <BEGIN: "begin">
    | <END: "end">
    | <IS: "is">
    | <SKI: ("skip")>
    | <DIGIT: ["0"-"9"]>
    | <LETTER: (["a"-"z","A"-"Z"])>
    | <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*>
    | <EMPTY: "" > : DEFAULT
}


//TOKEN:{
//    <NEMP_ARG_LIST: <IDENTIFIER> | (<IDENTIFIER><COMMA>)*>
//    |<ARG_LIST: <NEMP_ARG_LIST> | <EMPTY>>
//    |<COMP_OP: <EQ> | <NOTEQ> | <LT> | <LTEQ> | <GT> | <GTEQ>>
//    |<CONDITION: (<TILDA>)*
//        | (<OBRA>)*(<CBRA>)*
//        | <EXPRESSION><COMP_OP><EXPRESSION>
//        |(<AND><OR>)*>
//    |<FRAGMENT: <IDENTIFIER> | <MINUS><IDENTIFIER>|<DIGIT>|<TRUE>|<FALSE>>
//    |<EXPRESSION: <FRAGMENT><BINARY_ARITH_OP><FRAGMENT>
//        |(<OBRA>)*(<CBRA>)*
//        |<IDENTIFIER><OBRA><ARG_LIST><CBRA>
//        | <FRAGMENT>>
//    |<STATEMENT: <IDENTIFIER><ASIGN><EXPRESSION><SCOLON>
//        | <IDENTIFIER><OBRA><ARG_LIST><CBRA><SCOLON>
//        | (<BEGIN>)*(<END>)*
//        | (<IF><CONDITION><BEGIN>)*(<END>)*
//        | (<ELSE><BEGIN>)*(<END>)*
//        | (<WHILE><BEGIN>)*(<END>)*
//        | <SKI><SCOLON>>
//    |<STATEMENT_BLOCK: (<STATEMENT>)* | <EMPTY>>
//    |<MAIN_BLOCK: <MAIN><BEGIN><DECL_LIST><STATEMENT_BLOCK><END>>
//    |<NEMP_PARAM_LIST: <IDENTIFIER><COLON><TYPE> |
//            (<IDENTIFIER><COLON><TYPE><COMMA>)*>
//    |<PARAM_LIST: <NEMP_PARAM_LIST> | <EMPTY>>
//    |<TYPE: <INT> | <BOOL>| <VOID>>
//    |<FUNCTION: <TYPE><IDENTIFIER><OBRA><PARAM_LIST><CBRA><IS><DECL_LIST><BEGIN><STATEMENT_BLOCK><RET><OBRA>(<EXPRESSION> | <EMPTY>)<CBRA><END>>
//    |<FUNCTION_LIST: (<FUNCTION>)*|<EMPTY>>
//    |<CONST_DECL: <CONST><IDENTIFIER><COLON><TYPE><ASIGN><EXPRESSION>>
//    |<VAR_DECL: <VAR><IDENTIFIER><COLON><TYPE>>
//    |<DECL: <VAR_DECL> | <CONST_DECL>>
//    |<DECL_LIST: (<DECL><SCOLON>)*|<EMPTY>>
//    |<PROGRAM: <DECL_LIST><FUNCTION_LIST><MAIN>>
//}

void Start () : {}
{
  Programme()
}

void Programme () : {}
{
    declarationList()
    functionList()
    //mainMethod()
}

void functionList () : {}
{
    function()
}

void function () : {}
{
    type()identifier()<OBRA>paramList()<CBRA><IS>declarationList()<BEGIN>statementBlock()<RET><OBRA>(expression() | <EMPTY>)<CBRA><END>
}

void paramList () : {}
{
    nonEmptyParamList() | <EMPTY>
}

void nonEmptyParamList () : {}
{
    identifier()<COLON>type()(identifier()<COLON>type()<COMMA>)*
}

void statementBlock () : {}
{
    statement()
}

void statement () : {}
{

    identifier()(<ASIGN>expression()| <OBRA>argList()<CBRA>)<SCOLON>
    | (<IF> | <WHILE>) condition() <BEGIN> statementBlock() <END>
    | (<ELSE> | <EMPTY>) <BEGIN> statementBlock() <END>
    | <SKI>
}

void condition () : {}
{
    (<EMPTY> | <TILDA> | <OBRA>)expression()comparisionOp()expression()((<OR> | <AND>)expression()comparisionOp()expression())*(<EMPTY> | <CBRA>)
}

void comparisionOp () : {}
{
    <EQ> | <NOTEQ> | <LT> | <LTEQ> | <GT> | <GTEQ>
}

void declarationList () : {}
{
    declaration()<SCOLON>
}

void declaration () : {}
{
    varDeclaration()|constDeclaration() {System.out.println("Declaration");}
}

void constDeclaration () : {}
{
    <CONST>identifier()<COLON>type()<ASIGN>expression() {System.out.println("Const decalration");}
}

void varDeclaration () : {}
{
    <VAR><IDENTIFIER><COLON>type() {System.out.println("Var declaration");}
}

void expression () : {}
{
    LOOKAHEAD(2) fragment() | fragment()(
                BinOp()fragment() {System.out.println("Bin Op");}
                | <OBRA>argList()<CBRA> {System.out.println("Arg list");}
                )
    |<OBRA>expression()<CBRA>
}

void fragment () : {}
{
    identifier() {System.out.println("Identifier Fragment");}
    | <MINUS>identifier(){System.out.println("Negative identifier");}
    | <DIGIT>{System.out.println("Number fragment");}
    | boolOp(){System.out.println("Boolean fragment");}

}

void argList () : {}
{
    nonEmptyArgList() | <EMPTY>
}

void nonEmptyArgList () : {}
{
    identifier()
}

void identifier () : {}
{
    <IDENTIFIER>{System.out.println("IDENTIFIER");}
}

void type () : {}
{
    <INT> {System.out.println("Integer Type");}
    |<BOOL> {System.out.println("Boolean Type");}
    |<VOID> {System.out.println("Void Type");}
}

void boolOp() : {}
{
    <TRUE>{System.out.println("True");}
    |<FALSE>{System.out.println("False");}
}


void BinOp() : {}
{
    <PLUS> {System.out.println("Plus operator");}
    |<MINUS> {System.out.println("Minus operator");}
}